#import { Mutation, Connection } into Ethereum from "w3://ens/ethereum.web3api.eth"
#import { Mutation } into Ipfs from "w3://ens/ipfs.web3api.eth"

type Mutation {
  mintNFT(
    connection: Ethereum_Connection
    contractAddress: String!
    creatorAddress: String!
    content: String!
    metadata: String!
  ): Ethereum_TxResponse!

  registerPurchasableNFTContent (
    nftAddress: String!
    nftId: BigInt!
    registrant: String!
    data: String
    licenseManagerAddress: String!
    price: BigInt!
    sharePercentage: BigInt!
  ): String! # ID or maybe the content object?

  registerPurchasableContent(
    creatorAddress: String!
    licenseManagerAddress: String!
    content: String!
    metadata: String!
    registrant: String!
    data: String
    price: BigInt!
    sharePercentage: BigInt!
  ): String! # ID or maybe the content object?

  registerRevShareNFTContent (
    nftAddress: String!
    nftId: BigInt!
    registrant: String!
    data: String
    licenseManagerAddress: String!
    minSharePercentage: BigInt!
  ): String!

  registerRevShareContent(
    creatorAddress: String!
    licenseManagerAddress: String!
    content: String!
    metadata: String!
    registrant: String!
    data: String
    minSharePercentage: BigInt!
  ): String!

  # Do we need this approve? probably not, but might be useful as a
  # sort of standard library for polywrap
  approve(
    address: String!
    connection: Ethereum_Connection
    spender: String!
    amount: BigInt!
  ): Ethereum_TxResponse!
}

